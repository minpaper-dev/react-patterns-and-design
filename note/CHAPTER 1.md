# CHAPTER 1 - 리액트 안티패턴 소개

- 서버 상태

  - 네트워크를 통해 원격 서버에서 데이터를 가져오는데, 이 때의 데이터를 뜻한다.
  - 프론트엔드 애플리케이션 내에서 생성되고 관리되는 로컬 상태와는 달라 주의하여 다뤄야 한다.
  - 주의해야 할 사항

  1. 비동기 특성
  2. 오류 처리
  3. 로딩 상태
  4. 일관성
     - 프론트엔드 상태를 백엔드와 동기화하는 것을 의미
     - 실시간 애플리케이션이나 여러 사용자가 동일한 데이터를 변경하는 애플리케이션의 경우 특히 다루기 어려움
  5. 캐싱
     - 일부 서버 상태를 로컬에 저장하면 성능을 향상시킬 수 있지만, 데이터 불일치와 무효화 같은 문제가 생길 수 있다.
  6. 업데이트 및 낙관적(Optimistic UI)

- UI를 개발할 때 모든 것이 계획한 대로 최적의 사용자 경험을 제공하는 **정상 흐름**을 우선 고려합니다. 하지만 **예외 흐름**을 무시하고 개발한 UI 컴포넌트는 생각보다 힘든 상황을 불러올 수 있습니다.
- 예외 흐름으로 이어지는 복잡한 UI 예시

  1. 다른 컴포넌트에서 발생한 오류
     - 리액트의 에러 바운더리 기능은 자식 컴포넌트의 자바스크립트 오류를 잡아서 로그를 기록하고 애플리케이션 전체가 충돌하지 않도록 fallback UI를 표시합니다.
     - 에러 바운더리는 렌더링 과정, 생명주기 메서드, 하위 트리 컴포넌트 생성자에서 발생하는 에러를 포착합니다.
  2. 예측하지 못한 사용자 행동
     - ex) 텍스트 필드에 특수문자를 입력하거나, 양식을 너무 빨리 제출하거나 ..

- 리액트의 일반적인 안티패턴
  1. Prop Drilling
     - prop이 부모 컴포넌트에서 자식 컴포넌트로 전달될 때 여러 개의 중간 컴포넌트를 거쳐서 전달하게 되는 현상
     - 이러한 방식은 복잡도를 높이고 유지보수성을 떨어뜨린다.
     - 잠재적인 해결책은 Context API 사용 → Context API는 컴포넌트 트리의 모든 단계마다 prop을 명시적으로 전달할 필요 없이, 컴포넌트 간에 직접 데이터와 함수를 공유하는 방법을 제공한다.
  2. 컴포넌트 내 데이터 변환
     - 흔히 반복되는 실수 중 하나는 컴포넌트 내부에 복잡한 데이터 변환 로직을 직접 작성하는 것
     - ex) 백엔드에서 전달받은 데이터를 컴포넌트 내부에서 변환 작업 수행
     - 변환 작업을 컴포넌트 내부에 직접 구현하면 발생하는 문제
       1. 명확하지 않음
          - 데이터 가져오기, 변환, 렌더링 작업이 하나의 컴포넌트 안에서 이루어지므로 해당 컴포넌트가 어떤 역할을 하는 지 알기 어려움
       2. 재사용성이 떨어짐
          - 다른 컴포넌트에서 유사한 변환이 필요한 경우 로직의 중복 발생
       3. 테스트하기 어려움
          - 변환 로직을 고려해야 하므로 테스트 코드의 복잡도 증가
     - 데이터 변환 로직과 컴포넌트를 분리하는 것으로 해결 - ex) 유틸리티 함수, Custom Hook
  3. 뷰 영역의 복잡한 로직
     - 뷰 컴포넌트 내부에 비즈니스 로직을 다루는 것
     - 발생하는 문제
       1. 재사용성
          - 다른 컴포넌트에서 유사한 필터가 필요한 경우 로직 중복
       2. 테스팅
          - 렌더링뿐만 아니라 비즈니스 로직도 테스트해야하므로 단위 테스트가 복잡해진다.
       3. 유지보수성
          - 애플리케이션이 커지면서 더 많은 로직이 추가되기 때문에 유지보수하기 어려워진다.
     - 컴포넌트를 재사용 가능하고 유지보수하기 쉽게 만들기 위해서는 관심사 분리 원칙을 지켜야한다. (= 각각의 모듈 또는 함수가 하나의 기능에 대한 책임만 가져야 한다는 것, 단일 책임 원칙)
  4. 테스트 부족
     - ex) 장바구니 기능 구현 - 테스트가 없다면 가격의 불일치, 보안 취약성 문제가 발생할 수 있다.
     - 테스트 코드가 없다면 사용자가 직접 확인하기 전까지는 오류 상황을 알 수 없으므로 테스트 주도 개발(TDD)을 시작해야 한다. (테스트 코드 먼저 작성 후 실제 컴포넌트 로직을 나중에 작성하는 것을 권장)
  5. 중복된 코드
     - 코드베이스에서 유사하거나 동일한 코드 조각이 애플리케이션의 여러 부분에 흩어져 있는 것
     - 버그가 발견되거나 개선이 필요할 때, 각각의 중복된 코드 모두를 변경해야하므로 오류가 발생할 가능성이 높아진다.
     - 중복 배제 원칙(DRY)
     - 공통 로직을 유틸리티 함수나 고차 컴포넌트로 모아서 관리하면, 유지보수하기 편하고 가독성 높은 코드가 되며 오류 발생 가능성이 줄어든다.
  6. 너무 많은 기능을 가진 컴포넌트
     - 거대한 prop 목록이 있어서 다양한 기능을 담당
     - 단일 책임 원칙에 위배
     - 핵심 기능을 분석하고 부가적인 지원 로직들을 더 작고 집중된 컴포넌트나 훅으로 분리해야 한다.
